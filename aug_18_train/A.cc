// A
// Template generated by oi_helper (https://github.com/onion108/oi_helper)
//

#include <iostream>
#include <algorithm>
#include <iterator>
#include <type_traits>
#include <utility>
#include <vector>
#include <map>

using std::cin;
using std::cout;
using std::endl;

// An abstract type to present an item.
struct Thing {

    private:
    int _weight;
    int _value;

    public:

    // Construct a thing with given weight and value.
    Thing(int w, int v) : _weight(w), _value(v) {}

    // Get the weight of the thing.
    int weight() const {
        return _weight;
    }

    // Get the value of the thing.
    int value() const {
        return _value;
    }

};

// A storage abstract data model.
template <typename _Container = std::vector<Thing> >
class Storage {

    static_assert(std::is_same<typename _Container::value_type, Thing>::value, "The value type of _Container must be a Thing! ");

    // The inner container.
    _Container _inner;
    
    public:

    // Construct a storage.
    Storage() : _inner() {}

    // Add a thing to the storage.
    void append(const Thing& __n) {
        _inner.push_back(__n);
    }

    // Add a thing to the storage (automatically convert to an instance of type `Thing`. )
    void append(int __w, int __v) {
        _inner.push_back(Thing(__w, __v));
    }

    // Iterator used to iterate over the things.
    // This function returns the iterator points to the beginning.
    std::vector<Thing>::iterator begin() noexcept {
        return _inner.begin();
    }

    // Iterator used to iterate over the things.
    // This function returns the iterator points to past-the-end.
    std::vector<Thing>::iterator end() noexcept {
        return _inner.end();
    }

};

// Analyze two storages, in total.
// Use template to support `Storage` and its reference types.
// Use template metaprogramming to make sure the S0 and S1 must be one of `Storage`, `Storage &` and `Storage &&`.
template <typename S0, typename S1>
std::vector<std::pair<int, int>> merge_analyze(S0 __s0, S1 __s1) {

    // Check the type to make sure it's the type we want.
    // This two `static_assert`s make sure that S0 and S1 are both `Storage` or the reference of `Storage`.
    static_assert(
        (std::is_reference<S0>::value) ?                                                                 // Check if `S0` is a reference.
            std::is_same<typename std::remove_reference<S0>::type, Storage<std::vector<Thing>>>::value : // If it is, remove the reference on it and compare it with `Storage`.
            std::is_same<S0, Storage<std::vector<Thing>>>::value                                         // Otherwise, just compare it with `Storage`.
        ,
        "Invalid type for __s0: Should be reference of Storage (or the Storage instance). "
    );

    static_assert(
        (std::is_reference<S1>::value) ?                                                                 // Check if `S0` is a reference.
            std::is_same<typename std::remove_reference<S1>::type, Storage<std::vector<Thing>>>::value : // If it is, remove the reference on it and compare it with `Storage`.
            std::is_same<S1, Storage<std::vector<Thing>>>::value                                         // Otherwise, just compare it with `Storage`.
        ,
        "Invalid type for __s1: Should be reference of Storage (or the Storage instance). "
    );

    // The bucket to analyze.
    std::map<int, int> bucket;

    // Iterate over all the items in the storage #0.
    for (auto i : __s0) {
        bucket[i.value()] += i.weight();
    }

    // Iterate over all the items in the storage #1.
    for (auto i : __s1) {
        bucket[i.value()] += i.weight();
    }

    // Return the bucket in the vector form to make sort and iterating easier.
    std::vector<std::pair<int, int>> v;
    for (auto i : bucket) {
        v.push_back(i);
    }
    return v;
}

// The entry function of the program.
int main() {

    // The storages.
    Storage<std::vector<Thing>> s0;
    Storage<std::vector<Thing>> s1;

    // First we input the data of the first storage.
    int size_of_storage_0;
    cin >> size_of_storage_0;

    // Repeat `size_of_storage_0` times.
    for (int i = 0; i < size_of_storage_0; i++) {

        // Input the info of the current thing.
        int __cthing_w, __cthing_v;
        cin >> __cthing_v >> __cthing_w;
        
        // Add it to the storage.
        s0.append(__cthing_w, __cthing_v);

    }

    // Then input the data of the second storage.
    int size_of_storage_1;
    cin >> size_of_storage_1;

    // Repeat `size_of_storage_1` times.
    for (int i = 0; i < size_of_storage_1; i++) {

        // Input the info of the current thing.
        int __cthing_w, __cthing_v;
        cin >> __cthing_v >> __cthing_w;

        // Add it to the storage (too).
        s1.append(__cthing_w, __cthing_v);

    }

    // Then analyze them.
    // Store the analyzed content to sort and print them.
    // Use references to boost.
    auto analyzed_result = merge_analyze<Storage<std::vector<Thing>>&, Storage<std::vector<Thing>>&>(s0, s1);

    // Sort the analyzed result by value.
    // Use const references to boost.
    std::sort(analyzed_result.begin(), analyzed_result.end(), [](const std::pair<int, int>& x, const std::pair<int, int>& y) {
        return x.first < y.first;
    });

    // Display the values separated in spaces and new-lines.
    // Use rvalue references to boost.
    for (auto&& i : analyzed_result) {
        cout << i.first << ' ' << i.second << endl;
    }

}
