// B
// Template generated by oi_helper (https://github.com/onion108/oi_helper)
//
// Program author 27Onion, contest https://www.xinyoudui.com/courses/165/, B
// All right reserved. (2022)
//

#include <algorithm>
#include <iostream>
#include <map>
#include <vector>

using std::cin;
using std::cout;
using std::endl;

// The number abstract type.
// The declaration of this type is in order to make it more easy to transform int into long long or other integer
// types if needed.
using Number = int;

class ProblemSolver {

  // Data Area

  // The length of the breaking time for each subject.
  Number breaking_length;

  // Subject freezing time.
  std::vector<Number> freeze_time;

  // Homeworks data.
  std::vector<int> homeworks;

  // Store the answer of the problem.
  Number answer;

  // End Data

  // Initialize stage.
  void _init() { 

    breaking_length = 0;

    answer = 0;

  }

  // Input stage.
  void _input() {
    int n;
    cin >> n >> this->breaking_length;

    // Input homeworks data.
    for (int i = 0; i < n; i++) {

      int current;
      cin >> current;

      this->homeworks.push_back(current);

      // Initialize freeze time for the current subject.
      freeze_time[current] = -1;
      if (freeze_time.size() <= current-1) {
        freeze_time.push_back(0);
      }

    }
  }

  // Generate a sequence about the order of doing homeworks.
  std::vector<int>& _seq_gen() {
    return this->homeworks;
  }

  // Update the freezing times.
  void _update_freezing() {
    for (auto& i : freeze_time) {
      if (i == 0) {
        // Unfreeze if the number is drop to zero.
        i = -1;
        continue;
      }
      // Otherwise, decrease the value of it.
      if (i != -1) {
        i = i - 1;
      }
    }
  }

  // Solve the problem.
  void _solve() {
    auto seq = _seq_gen();
    int seq_ptr = 0;
    int homework_unfinished = homeworks.size();

    // Start main loop.
    while (homework_unfinished) {

      auto homework_to_do = seq[seq_ptr];

      // If this subject is still freezing, then we can't do the next homework because we must do homeworks in order.
      // i.e., all the subjects are freezing,
      // So just skip this loop.
      if (freeze_time[homework_to_do] != -1) {
        _update_freezing();
        answer++;
        continue;
      }
      // Otherwise, do this homework, and freeze it.
      homework_unfinished--;
      freeze_time[homework_to_do] = breaking_length;
      
      _update_freezing();
      seq_ptr += 1;
      seq_ptr %= seq.size();
      answer++;
    }

  }

  // Output the answer.
  void _output() {
  
    cout << answer << endl;

  }

  // Finishing stage.
  void _finish() {}

public:
  // Initialize a solver.
  // This solver class is splitted into five stages,
  // where:
  // Initialize Stage (_init()): Initialize some necessary data and prepare for the input stage.
  // Input Stage (_input()): Input data from the stdin (may be redirected) and store them into some fields.
  // Solve stage (_solve()): Solve the problem with the inputted data and some restrictions in the problem description.
  // Output Stage (_output()): Output the result to the stdout.
  // Finish Stage (_finish()): Do something when destructing the problem solver, if need (e.g., releasing resources).
  //
  // In the initializer, initialize stage will be called.
  //
  ProblemSolver() { _init(); }

  // Solve the problem.
  // In this method, input stage, solve stage and output stage will be called in order.
  void solve() {

    _input();

    _solve();

    _output();

  }

  // Finishing a solver.
  // In this method, finish stag will be called.
  ~ProblemSolver() { _finish(); }
};

int main() {

  ProblemSolver solver;

  solver.solve();

}
