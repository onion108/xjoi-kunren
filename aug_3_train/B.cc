// B
// Template generated by oi_helper (https://github.com/onion108/oi_helper)
//

#include <iostream>
#include <algorithm>

using std::cin;
using std::cout;
using std::endl;
using number_t = int;

/* Debug Kit Start */

#ifdef __DEBUG__
#define debug_do(__b) __b
#else
#define debug_do(__b)
#endif

/* Debug Kit End */

struct coordinate_t {
    int x;
    int y;
    coordinate_t operator+(coordinate_t rhs) {
        return coordinate_t { x + rhs.x, y + rhs.y };
    }
};

static const int MAXN = 1024;
int g_maze[MAXN][MAXN];
bool g_checkpoints[MAXN][MAXN];
bool g_visited[MAXN][MAXN];
number_t g_ans = 1919810+1e7;

void dfs(number_t len, coordinate_t current_point, int point_checked, int total_points_need_to_check, int n, int m) {
    if (point_checked == total_points_need_to_check) {
        // Checked all checkpoints
        g_ans = std::min(g_ans, len);
        return;
    }
    if (g_maze[current_point.x][current_point.y]) {
        return;
    }
    if (g_visited[current_point.x][current_point.y]) {
        return;
    }
    if (current_point.x <= 0 || current_point.y <= 0 || current_point.x > n || current_point.y > m) {
        return;
    }
    g_visited[current_point.x][current_point.y] = true;
    coordinate_t deltas[] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    for (int i = 0; i < 4; i++) {
        dfs(len+1, current_point+deltas[i], point_checked + (g_checkpoints[current_point.x][current_point.y] ? 1 : 0), total_points_need_to_check, n, m);
    }
    g_visited[current_point.x][current_point.y] = false;
}

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> g_maze[i][j];
        }
    }
    for (int i = 1; i <= k; i++) {
        int x, y;
        cin >> x >> y;
        g_checkpoints[x][y] = 1;
    }
    int x0, y0;
    cin >> x0 >> y0;
    dfs(1, {x0, y0}, 0, k, n, m);
    if (g_ans != 1919810+1e7) {
        cout << g_ans << endl;
    } else {
        cout << -1 << endl;
    }
}

