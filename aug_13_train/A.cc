// A
// Template generated by oi_helper (https://github.com/onion108/oi_helper)
//

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

using std::cin;
using std::cout;
using std::endl;


/* Debug Kit Start */

#ifdef __DEBUG__
#define debug_do(__b) __b
#else
#define debug_do(__b)
#endif

/* Debug Kit End */



static const int MAXN = 1e5+114514;

enum class op_code {
  MOVE_EAST,
  MOVE_SOUTH,
  MOVE_NORTH,
  MOVE_WEST,
};

struct point_t {
  int x;
  int y;
};

int main() {
  std::string s;
  cin >> s;
  
  std::vector<op_code> commands;
  for (auto i : s) {
    
    switch (i) {
      
      case 'E':
      commands.push_back(op_code::MOVE_EAST);
      break;
      
      case 'W':
      commands.push_back(op_code::MOVE_WEST);
      break;
      
      case 'S':
      commands.push_back(op_code::MOVE_SOUTH);
      break;
      
      case 'N':
      commands.push_back(op_code::MOVE_NORTH);
      break;
      
    }
    
  }
  int pc = 0;
  
  point_t dpoint = {0, 0};
  for (auto i : commands) { 
    switch (i) {
      
      case op_code::MOVE_EAST:
      dpoint.x++;
      break;
      
      case op_code::MOVE_WEST:
      dpoint.x--;
      break;
      
      case op_code::MOVE_NORTH:
      dpoint.y++;
      break;
      
      case op_code::MOVE_SOUTH:
      dpoint.y--;
      break;
      
    }
  }
  
  int target_emulate_to;
  cin >> target_emulate_to;
  // target_emulate_to -= 1;
  point_t point;
  point.x = dpoint.x * (target_emulate_to / commands.size());
  point.y = dpoint.y * (target_emulate_to / commands.size());
  target_emulate_to %= commands.size();
  while(pc != target_emulate_to) {
    switch (commands[pc % commands.size()]) {
      
      case op_code::MOVE_EAST:
      point.x++;
      break;
      
      case op_code::MOVE_WEST:
      point.x--;
      break;
      
      case op_code::MOVE_NORTH:
      point.y++;
      break;
      
      case op_code::MOVE_SOUTH:
      point.y--;
      break;
      
    }
    pc++;
  }
  cout << point.x << ' ' << point.y << endl;
}

