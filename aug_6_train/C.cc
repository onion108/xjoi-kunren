// D
// Template generated by oi_helper (https://github.com/onion108/oi_helper)
//

#include <iostream>
#include <algorithm>
#include <cstddef>
#include <string>

using std::cin;
using std::cout;
using std::endl;


/* Debug Kit Start */

#ifdef __DEBUG__
#define debug_do(__b) __b
#else
#define debug_do(__b)
#endif

/* Debug Kit End */

/**
 * The bits128 type.
 * Can contain 128 bits, and do some bit operations.
 */
struct bits128 {
  private:
  uint64_t high64;
  uint64_t low64;
  int bitcount;
  public:
  bits128(long long high64, long long low64, int bitcount = -1) : high64(high64), low64(low64) {
    if (bitcount == -1) {
      bitcount = 0;
      auto l = low64;
      auto h = high64;
      if (!high64) {
        while (l != 0) {
          l /= 2;
          bitcount++;
        }
      } else {
        bitcount = 64;
        while (h != 0) {
          h /= 2;
          bitcount++;
        }
      }
    } else {
      this->bitcount = bitcount;
    }
  }
  /**
   * Convert a string to bits128.
   */
  bits128(const std::string& s) {
    high64 = 0;
    low64 = 0;
    int cnt = s.length() - 1;
    int shift = 0;
    bitcount = s.length();
    for (int i = 0; i < 64; i++) {
      if (cnt < 0) {
        high64 = 0;
        debug_do({
          cout << "DEBUG at bits128::bits128" << endl;
          cout << low64 << endl;
        })
        return;
      }
      low64 += uint64_t(s[cnt] - '0') << shift;
      debug_do({
        cout << '[' << (uint64_t(s[cnt] - '0') << shift) << ']';
      })
      cnt--;
      debug_do({
        cout << "DEBUG AT bits128::bits128" << endl;
        cout << shift << ' ';
      })
      shift += 1;
    }
    shift = 0;
    for (int i = 0; i < 64; i++) {
      if (cnt < 0) {
        debug_do({
          cout << low64 << ' ' << high64 << endl;
        })
        return;
      }
      high64 += uint64_t(s[cnt] - '0') << shift;
      cnt--;
      debug_do({
        cout << "DEBUG AT bits128::bits128" << endl;
        cout << shift << ' ';
      })
      shift += 1;
    }
    debug_do({
      cout << low64 << ' ' << high64 << endl;
    })
  }
  bits128 operator^(const bits128& rhs) {
    return bits128(high64 ^ rhs.high64, low64 ^ rhs.low64, bitcount);
  }
  std::string to_string() const {
    std::string result;
    auto h = high64;
    auto l = low64;
    if (h == 0) {
      while (l != 0) {
        result += (l % 2) + '0';
        l /= 2;
      }
    } else {
      for (int i = 0; i < 64; i++) {
        result += (l % 2) + '0';
        l /= 2;
      }
      while (h != 0) {
        result += (h % 2) + '0';
        h /= 2;
      }
    }
    std::string true_result;
    for (auto i = result.rbegin(); i != result.rend(); i++) {
      true_result += *i;
    }
    return true_result;
  }
  bits128 circular_lshift() {
    if (high64) {
      // Save the highest bit
      auto highest = (high64 & (1ll << (bitcount - 65))) >> (bitcount - 65);
      // Save the highest bit of low 64
      auto l_highest = (low64 & (1ull << 63)) >> 63;
      // Calculate new h/l
      uint64_t new_high64 = (high64 << 1) + l_highest;
      uint64_t new_low64 = (low64 << 1) + highest;
      // Remove the highest bit.
      if (bitcount <= 127) {
        new_high64 = (~(~(new_high64) | (1ull << (bitcount-64))));
      }
      return bits128(new_high64, new_low64, bitcount);
    } else {
      auto highest = (low64 & (1ull << (bitcount - 1))) >> (bitcount - 1);
      debug_do({
        cout << "DEBUG at bits128::circular_lshift -> " << endl;
        cout << highest << endl;
      })
      uint64_t new_low64 = (low64 << 1) + highest;
      // Set the overflow bits to 0.
      if (bitcount <= 63) {
        new_low64 = (~(~(new_low64) | (1ull << bitcount)));
      }
      return bits128(0, new_low64, bitcount);
    }
  }
  bits128 operator&(const bits128& rhs) const {
    return bits128(high64&rhs.high64, low64&rhs.low64, bitcount);
  }
  bits128 operator~() const {
    return bits128(~high64, ~low64, bitcount);
  }
  bits128 operator|(const bits128& rhs) const {
    return bits128(high64 | rhs.high64, low64 | rhs.low64, bitcount);
  }
  bits128 xor_low(int m, const bits128& rhs) {
    debug_do({
      cout << "bits128::xor_low: " << this->to_string() << " ^ " << rhs.to_string() << " (low " << m << "). \n";
    })
    auto mask = mask_low(m);
    auto low_m = (*this) & mask;
    auto other_part = (*this) ^ low_m;
    return (low_m) ^ rhs | other_part;
  }
  static bits128 mask_low(int low_m) {
    bits128 mask_low(0, 0, 128);
    for (int i = 0; i < low_m; i++) {
      mask_low = mask_low.circular_lshift() | bits128(0, 1, -1);
    }
    debug_do({
      cout << mask_low.to_string() << endl;
    })
    return mask_low;
  }
};

static const int MAXN = 1e5+114514;

int main() {
  debug_do({
    cout << "[DEBUG MODE ON]\n";
    cout << endl;
    cout << endl;
    cout << bits128("111010101").xor_low(5, bits128("10101")).to_string() << endl;
  })
  int s_len, key_len, l, k;
  cin >> s_len >> key_len >> l >> k;
  std::string encrypted_raw, key_raw;
  cin >> key_raw >> encrypted_raw;
  bits128 encrypted(encrypted_raw);
  bits128 key(key_raw);
  bits128 decrypted(encrypted_raw);
  for (int i = 0; i < k; i++) {
    for (int j = 0; j < l; j++) {
      decrypted = decrypted.circular_lshift();
      debug_do({
        cout << "internal$0: " << decrypted.to_string() << endl;
      })
    }
    decrypted = decrypted.xor_low(key_len, key);
    debug_do({
      cout << "internal result: " << decrypted.to_string() << endl;
    })
  }
  cout << decrypted.to_string() << endl;
}

